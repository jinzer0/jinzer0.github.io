---
layout: article
title: "[Algorithm] 투포인터 알고리즘 (Two Pointer Algorithm)"
subtitle: "알고리즘 설명"
date: 2022-05-14 22:09:42 +0900
tags: Algorithm C
mode: immersive
header:
  theme: dark
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    # gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
    src: "/assets/img/background/IMG_3911.jpg"
---

# 1. 알고리즘 설명 
***

투포인터 알고리즘(Two pointer algorithm)은 전체 탐색시 시간 초과가 나는 경우 사용한다. 왜 이름이 투포인터냐 하면, 1차원 배열에서 임의의 두 포인터로 조작하여 답을 찾기 때문이다.   
투포인터 알고리즘을 사용하여 해결하는 대표적인 문제는 1차원 배열에서 임의의 원소들이 있을 때, 부분 배열의 합이 임의의 수가 되는 되는 개수, 혹은 그 부분 배열의 앞과 끝의 인덱스를 구하는 문제가 있다.   
전체 탐색이 필요하지 않는 경우 이 알고리즘을 택하면 시간 복잡도를 낮출 수 있다. 임의의 조건을 설정하여 그 조건에 맞지 않는 경우 바로 다음 경우의 수로 넘어가기 때문이다. 
## 예시
예시를 들어보자면, 요소가 자연수인 1차원 배열에서 연속적인 부분 배열의 모든 요소가 임의의 수보다 작은 부분 배열을 개수를 구한다고 생각해보자.   
> ![1](/assets/img/post/2022-05-14/스크린샷 2022-05-15 오전 12.39.32.png)   

먼저 요소가 3, 2, 4, 8, 5, 1인 배열이 있다. 이 배열에서 부분 배열의 모든 요소가 6보다 작은 부분 배열의 수를 구해보자.

> ![1](/assets/img/post/2022-05-14/스크린샷 2022-05-15 오전 12.42.02.png)

포인터 A와 B는 배열의 첫 요소로 초기화 된 상태이다. 포인터 B에 해당하는 요소가 6보다 작은지 검사한다. 여기서 포인터 B는 현재 3이므로 6보다 작다.

> ![3](/assets/img/post/2022-05-14/스크린샷 2022-05-15 오전 12.44.38.png)

포인터 B는 순차적으로 다음 요소로 이동한다. 이동한 포인터 B가 가르키는 요소는 2이다. 이렇게 6보다 작은지 검사하고 작으면 포인터 B를 이동한다.

> ![4](/assets/img/post/2022-05-14/스크린샷 2022-05-15 오전 12.45.02.png)

이동한 포인터 B가 가르키는 요소도 4이다. 역시 이동한다.

> ![5](/assets/img/post/2022-05-14/스크린샷 2022-05-15 오전 12.45.58.png)

이동한 포인터 B는 8을 가르키고 있다. 따라서 포인터 A를 이동할 것이다.
> ![6](/assets/img/post/2022-05-14/스크린샷 2022-05-15 오전 12.47.35.png)

포인터 A를 이동했다. 그리고 포인터 A의 위치에 포인터 B도 이동한다.   

이러한 방식으로 일정 기준을 충족하지 않으면 바로 다음 경우의 수로 넘어감으로써 전체 탐색보다 보다 더 적은 시간을 소모한다. 그렇다면 투포인터 알고리즘을 이용해 대표적인 문제를 풀어보자.   

# 2. 문제 설명
***
N개의 자연수가 있는 배열이 있을 때, 이 수열의 i번쩨 수부터 j 번째 수까지의 합이 M이 되는 경우 i와 j를 구하시오. 입력 배열의 최대 길이는 1000이고, 요소의 범위는 1 ~ 10000이다.
## 입력
> 첫째 줄에는 배열의 길이 N과 부분 합 M을 입력한다.
> 두 번째 줄에는 배열 요소를 입력한다.

## 출력
> 첫째 줄에 i와 j를 출력한다. 만약 정답이 여러 개인 경우 그 중 하나만 출력해도 인정.

## 문제 출처
> 아주대학교 컴퓨터공학과


# 3. 사고하기
***

만약 이 문제를 전체탐색하면 시간 복잡도는 최대 n^2가 되므로 시간 초과가 될 것이다. 하지만 투포인터 알고리즘을 사용한다면 시간 복잡도는 최대 n이 되므로 효율적인 풀이가 가능하다. 또한 앞서 예시와 달리 모든 경우의 수를 구하는 것이 아닌 기준을 만족하는 경우만 구하는 것이므로 포인터 A가 이동할 때 포인터 B도 동시에 포인터 A의 위치로 이동할 필요가 없다.
즉, 앞서 예시의 마지막과 같은 상황이 전혀 일어나지 않는다.   

그렇다면 합이 M이 되는 경우를 어떻게 찾을까? 현재 부분 배열의 요소들 합을 M과 대소 비교하면 된다. 만약 부분합이 M보다 크다면 포인터 A(i)를 오른쪽으로 이동한다. 반대로 부분합이 M보다 작다면 포인터 B(j)를 오른쪽으로 이동한다. 만약 부분합이 기준과 같다면 그 때 i와 j를 출력한다. 포인터 i, j가 같은 요소를 가리킬 때가 있다. 이때 부분합은 그 요소 값과 같다.   
투포인터 알고리즘에서 특징은 포인터 j의 인덱스는 포인터 i의 인덱스보다 크거나 같고, 같은 요소를 가리킬 수 있다는 점이다. 또한 부분 탐색으로 전체 탐색에 비해 적은 시간이 소요된다.

## 의사 코드
1. 배열 길이 N과 부분합 M 입력 받음
2. 배열 요소 입력 받음
3. 포인터 i, j 배열 첫 요소로 초기화
4. 반복문 및 while문으로 M과 부분합 대소 비교를 통해 포인터 i, j 이동
5. 부분합이 M과 같은 경우 i, j 출력

# 3. 코드 작성
***

```c
void find_all_sequence(int *arr, int length, int M) {
    // 포인터 i와 j, sum 초기화
    int *pi, *pj, sum = 0;
    pi = arr;
    pj = arr;
    for (int i = 0; i < length; ++i) { // 배열 길이만큼 반복
        while (pi < arr + length && sum < M) { // pj 이동
            sum += *pj;
            pj++;
        }

        if (sum == M) { // 부분 배열 합 sum과 M이 같다면 i, j 출력
            pj--;
            printf("%d %d\n", i, pj - arr);
            pj++;
        }
        sum -= *pi; 
        pi++; // 포인터 i 이동
    }
}

```

# 4. 평가
***

전체 탐색보다 부분 탐색하는 투포인터 알고리즘을 사용하는 것이 더 적은 시간을 소모했다. 추후 전체 탐색하는 코드를 작성해 결과를 비교할 것이다.